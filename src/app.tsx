import { JsonRpcClient } from "@defichain/jellyfish-api-jsonrpc";
import { address, WhaleApiClient } from '@defichain/whale-api-client';
import { SmartBuffer } from 'smart-buffer'
import { fromScript } from '@defichain/jellyfish-address'
import { CompositeSwap, DfTx, PoolId, PoolSwap, PoolAddLiquidity, AccountToAccount, AnyAccountToAccount, DepositToVault } from '@defichain/jellyfish-transaction'
import {
    VaultActive,
    VaultLiquidation,
    VaultState
  } from '@defichain/jellyfish-api-core/dist/category/loan'
import {
    ICXOrderInfo,
    ICXOfferInfo,
    ICXOrderStatus,
    ICXOrderType
} from '@defichain/jellyfish-api-core/dist/category/icxorderbook'
import {
    DfTxType
} from '@defichain/jellyfish-api-core/dist/category/account'
import BigNumber from "bignumber.js";
import { AbstractQueryOptions } from "sequelize/dist/lib/query";
import { CAccountToAccount, CAccountToUtxos, CAnyAccountToAccount, CCompositeSwap, CCreateVault, CDepositToVault, CICXClaimDFCHTLC, CICXCreateOrder, CICXMakeOffer, CICXSubmitDFCHTLC, CPoolAddLiquidity, CPoolRemoveLiquidity, CPoolSwap, CScript, CTakeLoan, CTransaction, OP_DEFI_TX, toOPCodes } from "@defichain/jellyfish-transaction/dist";
import { AddressActivity } from "@defichain/whale-api-client/dist/api/address";
import { account } from "@defichain/jellyfish-api-core";
import { AsyncQueueError } from "sequelize/dist";
import { MysqlError } from "mysql";


var node = "";

async function processPoolPairs() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });
    
    await con.connect();

    const result = await client.poolpair.listPoolPairs({
        start: 0,
        including_start: true,
        limit: 100
    }, true)

    for (const [id, info] of Object.entries(result)) {
        await asynqQuery(con, 'INSERT INTO poolpair SET ?', {id: id, symbol: info.symbol, reserveA: info.reserveA, reserveB: info.reserveB});
    }
}

async function processVaults() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });

    await con.connect();

    var last = undefined;

    const result:any = await client.loan.listVaults({
        start: last,
        including_start: last === undefined,
        limit: 10000
    })

    var Progress = require('ts-progress');
    var progress = Progress.create({total: result.length, pattern: 'Progress: {current}/{total} | Remaining: {remaining} | Elapsed: {elapsed} ', textColor: 'blue'});
    
    for (var i = 0; i < result.length; i++) {
        const x = result[i];
        const vault = await client.loan.getVault(x.vaultId);

        await asynqQuery(con, 'INSERT INTO vault SET ?', {vaultId: vault.vaultId, ownerAddress: x.ownerAddress, state:x.state});

        if (vault.state === VaultState.IN_LIQUIDATION) {
            const vaultLiq = vault as VaultLiquidation;

            vaultLiq.batches.forEach(async (y) => {
                y.collaterals.forEach(async (c) => {
                    const splitted = c.split('@');

                    await asynqQuery(con, 'INSERT INTO vault_batch_collateral SET ?', {vaultId: vault.vaultId, batchId: y.index.toString(), token: splitted[1], amount: Number(splitted[0])});
                });
            });
        }
        else {
            const vaultActive = vault as VaultActive;

            vaultActive.collateralAmounts.forEach(async (y) => {
                const splitted = y.split('@');

                await asynqQuery(con, 'INSERT INTO vault_collateral SET ?', {vaultId: vault.vaultId, token: splitted[1], amount: Number(splitted[0])});
            });
        }

        progress.update();
    }

}

async function processErroredAddresss() {
    const addresses = [
        'dP2iVskHtNYrGmKx1Fsz8hLm8XPKyB5svT',
        'dWYc5YJDXTBQVAceWKL8pHEivQLUgtrrxJ',
        'dSM1YHztnVPWrLYuCP9kEBBcDSbJ5K49Wp',
        'dVoAVmEG8aWdHwC7c523nw3PToQsUZwgYh',
        'df1qf7xyy77hkt8mrs50htpysea8y0tlpjpzuv4wcz',
        'dJa67xQ5PHBpkNBogLC6mR3RUH2JXwUVg2',
        'dXNb4XNcD3TbGQif5PY91cB79nQAe93fxe',
        'dMi25vdaCcx6c7KCetgQHFrkB3weFYm7A9',
        'dUkuhk6QCd6YRJ7t8bDJGxCR4jc1cMt76A',
        'dbx6Zu2rxtAzCPvecsohjQUJV8ututqnRM',
        'dP34ezGM1YemqK4WC5fW6tJekM6qLzH53F',
        'dZdneJ529k744yWnDir71N4Arwyhe4LBG4',
        'dZm44CaJAw68o3tcBFWjXr9cpWTC5B3EXc',
        'df1q9a6e0h35ssxpqrq4798g2klkl4ukydzf7lnuwl',
        'df1qr73786f9rsuy88pn0hhnw70ksac7ms2aajslyx',
        'df1qq0jyfv8e7z5nt4hw2ru7vp8pxes03tpu9x0qu2',
        'dDm6vhuNrAQHNKEDFxjJXsH4jfrKWYuSVp',
        'dMRrNjc5mPYxyoJemsRMgSqGxCsTidEKMp',
        'df1qkq06q7sq4mjnn2t5xa3mkxqec79966xq7je2s5',
        'dQPfF1tKpMTde6Dmbyn7kzjtp9Gw1ATaps',
        'df1qz2xnmmypwnfhqrlplfkgsvx995f4c8uq5hn2rz',
        'dRPX5iGu4pvXdenToxwxJmmiR9QuEfUvbJ',
        'dEUgLZVq9X3fWkE3FvvEV8BmZuLFSAk2wQ',
        'dWNh3msmW6VQjHTxt34LuM725ActsmmHyN',
        'dJ4w2Ph3piszxNuAJVFe3eVpVv6WQCBW5N',
        'dJP4XjSEoJN8SgNhG7rtS79Bn6amLiLsgY',
        'dXkAVAv37Fj2UmhgzKsfjRE4j5TZ7Yv4P9',
        'df1q2ltym34lhs8paryfl7laru4wth53gt2l698hrl',
        'dVutRmrFefwwRum7XC1NBM3Kdx2WfRRiph',
        'df1qvdf5zcgfzkq6all8224rrzkustvx0nfn0xkqm4',
        'df1qwd47cvgvjkndh98cprwwerqdayj04dnkruu34q',
        'db1V4XrhA3ZD2HdnPNY3U9riBVGWmcvGxx',
        'df1qgxn6gdxsgw4k4ma5d949j2wxshtg4wleaj0ws5',
        'dFawPFASr7M4Pa8e3bDWU41JT9ujKPEsRe',
        'dEo4mMvp7Kv9g9G7kq6cSymFXkJo4szhdX',
        'dbb5FVRpLaamWoBsPhdemhbYCDd8KnqTcT',
        'dDfmriMtRRboVBzmrcn9wmuQ46CVMmnpMg',
        'dSDghazZ7ha8wV7PNCPmU6qFyZ58RzZcpz',
        'dLMTkiFksgs3a5LyVnAVR6Y693TbdCBSjj',
        'dVWFBUN3xUH8YPuemJEjvHcwAQ8LCYqEPx',
        'dQjwQqk6ATW1Q76eUNu52C9DEk6SARCWzB',
        'df1q3m23jxww38adquvnpsks2nuahn0hryaucahn8m',
        'df1qahsjju2ksqadrvk5z96x2xykan2z5lnzucsz9u',
        'dGQpwQ6NerWzRyxtyL8NBjeWNW5atJWpCZ',
        'dHwkAmxZUyaLX1yZLAKUoiXY11RUmE4yhz',
        'dR2jwkawVhBjeGo3iHZucwr6wxEk4djPTi',
        'dbFvkp2ng7uQkz1yaLwEPeehqR18UHiVh7',
        'dNF9PzyFJXiappCDsNmRzuPBNf74cDChTR',
        'df1qcq9vvr8rzevnrvlux4f7nzqrhmzhxsx55pj33j',
        'df1qru9aphuglz2cf0hjtq9us8u336t0cf3yvfgzyf',
        'dTFYhTYZEdDn2x42KGudD5T8SeZndNEntW',
        'dPrs7s7rYReZiCgoxg2HfshFSDXzNFgD4T',
        'dFXjJztrXRasXcpAhTyWWrao67YrvwsqdA',
        'dYuYeCdtSx6o1WKHrdAdjbvjSVraQprVq9',
        'daYtj2nGtAFcc8Ky24NyPFeb2MFqug28iQ',
        'dEg222tsWgaGw5f8nqtue9s2rjqPjmAYqV',
        'dNA6uDEPt3wKiuxJssQixekTmyZGseeVwK',
        'dTV5pfhAdAMzbT4XWhwi2WWSouNoShFLeb',
        'dS3Ui5ZbWKDo615BED4tWs89Pqkzi3GDap',
        'dNPT7KMgwmHeHjgF5BSkeKGchwMBEBh8hp',
        'db7DG23cfPSGD7nCGrxhN5Ps8F2XHdwVwH',
        'dKd5acVWVpKvgeNYsXondLsLy5hrWSRFqC',
        'dL1YpPpQTkAJPw4rNr6qGMmy25jj52dL7Q',
        'dNB3DTRxk8dFXN2xYfSS5u2VFkmqrt2bqH',
        'dLbhsi1jRMqt3zUhUru7xY6wc4iAeNsoMq',
        'dPsWt7NGA9Wwpi7athzZsr1AEJD2dso8Xg'
    ];

    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });

    await con.connect();

    for (const i in addresses) {
        const x = addresses[i];

        try { 
            await checkAddress(client, con, x);
        }
        catch(e) {
            console.log(x + ": " + e);
        }
    }

    console.log("finished");
} 

async function processIcxOrders() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });

    await con.connect();

    const result: Record<string, ICXOrderInfo | ICXOfferInfo> = await client.icxorderbook.listOrders({
        closed: true,
        limit: 10000
    })

    const cliProgress = require('cli-progress');
    const progress = new cliProgress.SingleBar({
        format: '{percentage}% | {value}/{total} | {bar} | | Order: {order} || ETA: {eta}s',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
        fps: 5
    });

    progress.start(result.length, 0, {
        order: 'N/A'
    });

    for (let offerId in result) {
        var order = result[offerId] as ICXOrderInfo;

        if (order.status === ICXOrderStatus.FILLED && order.tokenFrom === "BTC" && order.type === ICXOrderType.INTERNAL) {
            const owner = order.ownerAddress;
            const closeHeight = (order.closeHeight as BigNumber).toNumber();

            //const closeTx = await client.wallet.getTransaction(order.closeTx as string);
            //const history = await client.account.listAccountHistory(owner);
            const historyFromBlock = await client.account.listAccountHistory(owner, {
                limit: 1,
                maxBlockHeight: closeHeight,
                txtype: DfTxType.ICX_CLAIM
            });
            const historyBeforeBlock = await client.account.listAccountHistory(owner, {
                limit: 10000,
                maxBlockHeight: closeHeight - 1
            });

            const btcValueBeforeClaim = historyBeforeBlock.reduceRight((prev: number, current) => {
                var btcs = current.amounts.filter((x) => x.split('@')[1]==='BTC');

                var totalBtcValue = btcs.reduce((prev: number, current, index, all) => {
                    const amount = parseFloat(current.split('@')[0]);

                    return prev + amount;
                }, 0);

                return prev + totalBtcValue;
            }, 0);

            if (historyFromBlock.length === 1) {
                var btcs = historyFromBlock[0].amounts.filter((x) => x.split('@')[1]==='BTC');
                const btcValueAfterClaim = btcs.reduce((prev: number, current, index, all) => {
                    const amount = parseFloat(current.split('@')[0]);

                    return prev + amount;
                }, 0);

                await asynqQuery(con, 'INSERT INTO icx_order SET ?', {
                    id: offerId, 
                    amountFrom: order.amountFrom.toNumber(), 
                    status: order.status,
                    closeTx: order.closeTx,
                    orderPrice: order.orderPrice.toNumber(),
                    ownerAddress: order.ownerAddress,
                    type: order.type,
                    amountAfterFilled: btcValueAfterClaim,
                    amountBeforeFilled: btcValueBeforeClaim,
                    unbackedBTC: btcValueAfterClaim - btcValueBeforeClaim,
                    furtherProcessed: 1
                });
            }
        }
    
        progress.update({
            order: offerId
        })
        progress.increment();
    }

}

async function processIcxOrderTransactions() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });

    await con.connect();

    const ocean = new WhaleApiClient({ url: 'https://ocean.defichain.com', network: 'mainnet', version: 'v0', timeout: options.timeout });
    const icxs:any = await asynqQuery(con, 'SELECT * FROM icx_order WHERE furtherProcessed=0');
    const addresses: string[] = icxs.map((order: any) => {
        return order.ownerAddress;
    });
    
    const tokens = await client.token.listTokens({
        including_start: true,
        limit: 1000,
        start: 0
    });

    const cliProgress = require('cli-progress');
    const progress = new cliProgress.SingleBar({
        format: '{percentage}% | {value}/{total} | {bar} || Address: {address} ||| ETA: {eta}s',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
        fps: 5
    });

    progress.start(addresses.length, 0, {
        address: 'N/A'
    });

    for (const addressIndex in addresses)
    {
        const address = addresses[addressIndex];

        await checkAddressTransactions(client, ocean, con, progress, tokens, address, 1);

        await asynqQuery(con, 'UPDATE icx_order SET furtherProcessed=1 WHERE ownerAddress=?', [address]);
    }
}

async function processIcxOrderTransactionsLevel(level: number) {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });

    await con.connect();

    await asynqQuery(con, "DELETE FROM `icx_account_to_account` WHERE level=?", [level]);
    await asynqQuery(con, "DELETE FROM `icx_pool_add` WHERE level=?", [level]);
    await asynqQuery(con, "DELETE FROM `icx_swap` WHERE level=?", [level]);
    await asynqQuery(con, "DELETE FROM `icx_transaction` WHERE level=?", [level]);
    await asynqQuery(con, "DELETE FROM `icx_vault` WHERE level=?", [level]);
    
    const ocean = new WhaleApiClient({ url: 'https://ocean.defichain.com', network: 'mainnet', version: 'v0', timeout: options.timeout });
    const icxs:any = await asynqQuery(con, 'SELECT * FROM icx_account_to_account WHERE level=?', [level-1]);
    const addresses: string[] = icxs.map((order: any) => {
        return order.addressTo;
    });
    
    const tokens = await client.token.listTokens({
        including_start: true,
        limit: 1000,
        start: 0
    });

    const cliProgress = require('cli-progress');
    const progress = new cliProgress.SingleBar({
        format: '{percentage}% | {value}/{total} | {bar} || Address: {address} ||| ETA: {eta}s',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
        fps: 5
    });

    progress.start(addresses.length, 0, {
        address: 'N/A'
    });

    for (const addressIndex in addresses)
    {
        const address = addresses[addressIndex];

        await checkAddressTransactions(client, ocean, con, progress, tokens, address, level);
    }
}

async function processIcxAccounts() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });

    await con.connect();

    const icxs:any = await asynqQuery(con, 'SELECT * FROM icx_order WHERE furtherProcessed=0');
    const level1:any = await asynqQuery(con, 'SELECT * FROM icx_account_to_account WHERE level=?', [1]);
    var addresses: string[] = icxs.map((order: any) => {
        return order.ownerAddress;
    });
    level1.forEach((element:any) => {
        addresses.push(element.addressTo);
    });

    const cliProgress = require('cli-progress');
    const progress = new cliProgress.SingleBar({
        format: '{percentage}% | {value}/{total} | {bar} || Address: {address} ||| ETA: {eta}s',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
        fps: 5
    });

    progress.start(addresses.length, 0, {
        address: 'N/A'
    });


    for (const addressIndex in addresses)
    {
        const address = addresses[addressIndex];
        progress.update({
            address: address
        });
        progress.increment();

        await checkICXAddress(client, con, address);
    }
}


async function checkICXAddress(client: JsonRpcClient, con: any, address: string) 
{
    var tokenBalances = new Map<string, number>();
    var accountBalance = await client.account.getAccount(address);

    accountBalance.forEach(async (x) => {
        var splitted = x.split('@');

        var token = splitted[1];

        tokenBalances.set(token, Number(splitted[0]));
    });
    
    try {
        tokenBalances.forEach(async (value: number, key: string) => {
            var result:any = await asynqQuery(con, 'SELECT * FROM icx_account_token WHERE address=? AND token=?', [address, key]);

            if (result.length === 0) {
                await asynqQuery(con, 'INSERT INTO icx_account_token SET ?', {address: address, token: key, amount: value});
            }
            else {
                await asynqQuery(con, 'UPDATE icx_account_token SET amount=? WHERE address=? AND token=?', [value, address, key]);
            }
        });
    }
    catch (e) {
        console.log(e);
    }

    return true;
}

async function checkAddressTransactions(client: JsonRpcClient, ocean: WhaleApiClient, con: any, progress: any, tokens: any, address: string, level: number) {
    await con.beginTransaction();

    var transactions = await ocean.address.listTransaction(address, 1000000);

    progress.update({
        address: address
    });
    progress.increment();

    transactions = transactions.sort((a, b) => {
        return a.block.height - b.block.height;
    });
    
    for (var tx in transactions)
    {
        const x = transactions[tx];
        
        if (x.type === 'vout') {
            continue;
        }

        try {
            var rawTx = await client.rawtx.getRawTransaction(x.txid, true, x.block.hash);
            
            for (const vout of rawTx.vout) {
                if (vout.scriptPubKey.asm.startsWith('OP_RETURN 44665478')) {
                    const hex = vout.scriptPubKey.hex;
                    const buffer = SmartBuffer.fromBuffer(Buffer.from(hex, 'hex'))
                    const stack = toOPCodes(buffer)
                    if (stack.length !== 2 || stack[1].type !== 'OP_DEFI_TX') {
                        return;
                    }
                    const dfTx = (stack[1] as OP_DEFI_TX).tx
        
                    //Process DFI TX further
                    //SWAP
                    //COMPOSITE_SWAP
                    //ACCOUNT_TO_ACCOUNT

                    await asynqQuery(con, 'INSERT INTO icx_transaction SET ?', {
                        address: address,
                        txid: x.txid,
                        height: x.block.height,
                        type: dfTx.name,
                        level: level
                    });

                    switch (dfTx.type) {
                        case CPoolSwap.OP_CODE:
                            var swap = dfTx as DfTx<PoolSwap>;
                            var fromToken = swap.data.fromTokenId;
                            var toToken = swap.data.toTokenId;
                            var toAddress = fromScript(swap.data.toScript, 'mainnet');
                            var fromAddress = fromScript(swap.data.fromScript, 'mainnet');
                            var fromAmount = swap.data.fromAmount.toNumber();

                            var toSymbol = tokens[toToken.toString()].symbol;
                            var fromSymbol = tokens[fromToken.toString()].symbol;

                            var history = await client.account.listAccountHistory(toAddress?.address, {
                                limit: 1,
                                maxBlockHeight: x.block.height,
                                txtype: DfTxType.POOL_SWAP
                            });
                            var toAmountHistoryEntry = history[0].amounts.filter((a) => a.split('@')[1]===toSymbol);
                            var toAmount = toAmountHistoryEntry.reduce((prev: number, current, index, all) => {
                                const amount = parseFloat(current.split('@')[0]);
            
                                return prev + amount;
                            }, 0);
                            
                            await asynqQuery(con, 'INSERT INTO icx_swap SET ?', {address: address, addressFrom: fromAddress?.address, addressTo: toAddress?.address, txId: x.txid, fromSymbol: fromSymbol, toSymbol: toSymbol, amountFrom: fromAmount, amountTo: toAmount, level: level});
                            
                            break;
                        case CCompositeSwap.OP_CODE:
                            var cswap = dfTx as DfTx<CompositeSwap>;
                            var fromToken = cswap.data.poolSwap.fromTokenId;
                            var toToken = cswap.data.poolSwap.toTokenId;
                            var toAddress = fromScript(cswap.data.poolSwap.toScript, 'mainnet');
                            var fromAddress = fromScript(cswap.data.poolSwap.fromScript, 'mainnet');
                            var fromAmount = cswap.data.poolSwap.fromAmount.toNumber();

                            var toSymbol = tokens[toToken.toString()].symbol;
                            var fromSymbol = tokens[fromToken.toString()].symbol;

                            var history = await client.account.listAccountHistory(toAddress?.address, {
                                limit: 1,
                                maxBlockHeight: x.block.height,
                                txtype: DfTxType.POOL_SWAP_V2
                            });
                            var toAmountHistoryEntry = history[0].amounts.filter((a) => a.split('@')[1]===toSymbol);
                            var toAmount = toAmountHistoryEntry.reduce((prev: number, current, index, all) => {
                                const amount = parseFloat(current.split('@')[0]);
            
                                return prev + amount;
                            }, 0);
                            
                            await asynqQuery(con, 'INSERT INTO icx_swap SET ?', {address: address, addressFrom: fromAddress?.address, addressTo: toAddress?.address, txId: x.txid, fromSymbol: fromSymbol, toSymbol: toSymbol, amountFrom: fromAmount, amountTo: toAmount, level: level});
                            
                            break;
                        case CAccountToAccount.OP_CODE:
                            var accountToAccount = dfTx as DfTx<AccountToAccount>;

                            accountToAccount.data.to.map(async scriptBalances => {
                                var toAddress = fromScript(scriptBalances.script, 'mainnet')?.address ?? 'N/A'

                                scriptBalances.balances.map(async balance => {
                                    var symbol = tokens[balance.token.toString()].symbol;

                                    await asynqQuery(con, 'INSERT INTO icx_account_to_account SET ?', {address: address, txId: x.txid, addressTo: toAddress, symbol: symbol, amount: balance.amount.toNumber(), level: level});
                                });
                            });

                            break;
                        case CAccountToUtxos.OP_CODE:
                            break;
                        case CAnyAccountToAccount.OP_CODE:
                            var anyAccountToAccount = dfTx as DfTx<AnyAccountToAccount>;

                            anyAccountToAccount.data.to.map(async scriptBalances => {
                                var toAddress = fromScript(scriptBalances.script, 'mainnet')?.address ?? 'N/A'

                                scriptBalances.balances.map(async balance => {
                                    var symbol = tokens[balance.token.toString()].symbol;

                                    await asynqQuery(con, 'INSERT INTO icx_account_to_account SET ?', {address: address, txId: x.txid, addressTo: toAddress, symbol: symbol, amount: balance.amount.toNumber(), level: level});
                                });
                            });
                            break;
                        case CPoolAddLiquidity.OP_CODE:
                            var poolAddData = dfTx as DfTx<PoolAddLiquidity>;

                            var from = poolAddData.data.from[0];
                            var a = from.balances[0];
                            var b = from.balances[1];

                            var symbolA = tokens[a.toString()].symbol;
                            var symbolB = tokens[b.toString()].symbol;

                            await asynqQuery(con, 'INSERT INTO icx_pool_add SET ?', {address: address, txId: x.txid, tokenA: symbolA, tokenB: symbolB, amountA: a.amount.toNumber(), amountB: b.amount.toNumber(), level: level});
                            break;
                        case CPoolRemoveLiquidity.OP_CODE:
                            break;
                        case CICXCreateOrder.OP_CODE:
                            break;
                        case CICXMakeOffer.OP_CODE:
                            break;
                        case CICXSubmitDFCHTLC.OP_CODE:
                            break;
                        case CICXClaimDFCHTLC.OP_CODE:
                            break;
                        case CCreateVault.OP_CODE:
                            break;
                        case CDepositToVault.OP_CODE:
                            var depositToVault = dfTx as DfTx<DepositToVault>;

                            var vaultId = depositToVault.data.vaultId;
                            var symbol = tokens[depositToVault.data.tokenAmount.token.toString()].symbol;
                            var amount = depositToVault.data.tokenAmount.amount.toNumber();

                            await asynqQuery(con, 'INSERT INTO icx_vault SET ?', {address: address, txId: x.txid, vaultId: vaultId, symbol: symbol, amount: amount, level: level});
                            break;
                        case CTakeLoan.OP_CODE:
                            break;
                    };
                    break;
                }
            }
        }
        catch(e) {
            console.log(x.txid + " " + e);
        }
    }

    await con.commit();
}

async function countAccountToAccountTransactions(address: string) {
    const options = {
        timeout: 10000000
    };
    const client = new JsonRpcClient('node', options)
    
    const history = await client.account.listAccountHistory(address, {
        limit: 10000
    })
    const btcA2AHistory = history.filter((x) => x.type === "AccountToAccount").filter((x) => x.amounts.filter((y) => y.split('@')[1] === 'BTC').length > 0);
    const btcValueAll = btcA2AHistory.reduceRight((prev: number, current) => {
        var btcs = current.amounts.filter((x) => x.split('@')[1]==='BTC');

        var totalBtcValue = btcs.reduce((prev: number, current, index, all) => {
            const amount = parseFloat(current.split('@')[0]);

            return prev + amount;
        }, 0);

        return prev + totalBtcValue;
    }, 0);

    const btcValueIn = btcA2AHistory.reduceRight((prev: number, current) => {
        var btcs = current.amounts.filter((x) => x.split('@')[1]==='BTC');

        var totalBtcValue = btcs.reduce((prev: number, current, index, all) => {
            const amount = parseFloat(current.split('@')[0]);

            if (amount > 0) {
                return prev + amount;
            }
            return prev;
        }, 0);

        return prev + totalBtcValue;
    }, 0);

    console.log("total value: " + btcValueAll);
    console.log("total value in: " + btcValueIn);
}

async function process() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });
    
    await con.connect();

    var accounts:any = await asynqQuery(con, 'SELECT * FROM account');
    var checkedAddresses = accounts.map((x:any) => x.address);
    var blocks:any = await asynqQuery(con, 'SELECT * FROM block ORDER BY height DESC LIMIT 0,1');
    var lastHeight = blocks.length > 0 ? blocks[0]?.height+1 : 0;
    
    var height = await client.blockchain.getBlockCount();
    var erroredBlocks = new Array()
    var erroredAddresses = new Array()
    
    const cliProgress = require('cli-progress');
    const progress = new cliProgress.SingleBar({
        format: '{percentage}% | {value}/{total} | {bar} | | Block: {block} | Address: {address} ||| ETA: {eta}s',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
        fps: 5
    });

    progress.start(height, lastHeight, {
        block: lastHeight,
        address: 'N/A'
    });

    for (var i = lastHeight; i < height; i++) {
        progress.update({
            block: i
        });

        try { 
            var blockHash = await client.blockchain.getBlockHash(i);
            var block = await client.blockchain.getBlock(blockHash, 2);

            for (var txNum = 0; txNum < block.tx.length; txNum++) {
                var tx = block.tx[txNum];

                const vouts = tx.vout.filter((x) => x.scriptPubKey.addresses);

                for (var voutNum = 0; voutNum < vouts.length; voutNum++) {
                    var vout = vouts[voutNum];

                    const addresses = vout.scriptPubKey.addresses.filter((x) => !checkedAddresses.includes(x.toString()));

                    addresses.forEach(async (x) => {
                        const address = x.toString();

                        checkedAddresses.push(address);

                        var result:any = await asynqQuery(con, 'SELECT * FROM account WHERE address=?', {address: address});

                        if (result.length === 0) {
                            await asynqQuery(con, 'INSERT INTO account SET ?', {address: address, timestamp: block.time, block: block.height});
                        }

                        progress.update({
                            address: x.toString()
                        });
    
                        try {
                            await checkAddress(client, con, address);
                        }
                        catch (e) {
                            erroredAddresses.push(x.toString());
                        }
                    });
                }
            }
        } catch (e) { 
            erroredBlocks.push(i);
        }

        await asynqQuery(con, 'INSERT INTO block SET ?', {height: i});

        progress.increment();
    }

    console.log('Errored Blocks:');
    console.log(erroredBlocks);

    console.log('Errored Addresses:');
    console.log(erroredAddresses);

    console.log("checked addresses: " + checkedAddresses.length)

    console.log("done");
}

async function processListAccounts() {
    //a91453fdbbbc979bbd68a2c83f1f5fc93aa884fa14c887@10
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });
    
    await con.connect();
    
    var last = "a91453fdbbbc979bbd68a2c83f1f5fc93aa884fa14c887";
    var loop = 0;

    while (true) {
        loop++;
        var result:any = await client.account.listAccounts({
            including_start: last === null,
            limit: 100,
            start: last === null ? undefined : last
        });

        if (result.length === 0) {
            console.log("done");
            break;
        }

        console.log("running....: " + loop + ":  " + last);

        for (var entry in result) {
            const account = result[entry];

            if (!account.owner.addresses) {
                continue;
            }

            if (account.owner.addresses.length == 0) {
                continue;
            }

            const address = account.owner.addresses[0];

            var account_result:any = await asynqQuery(con, 'SELECT * FROM account WHERE address=?', [address]);

            if (account_result.length === 0) {
                await asynqQuery(con, 'INSERT INTO account SET ?', {address: address, timestamp: -1, block: -1});
            }

            var splitted = account.amount.split('@');
            var token = splitted[1];
            var amount = Number.parseFloat(splitted[0]);

            var account_query:any = await asynqQuery(con, 'SELECT * FROM account_token WHERE address=? AND token=?', [address, token]);

            if (account_query.length === 0) {
                await asynqQuery(con, 'INSERT INTO account_token SET ?', {address: address, token: token, amount: amount});
            }
            else {
                await asynqQuery(con, 'UPDATE account_token SET amount=? WHERE address=? AND token=?', [amount, address, token]);
            }

            last = account.key;
        }
    }

    console.log("done");
}

async function processAllAddressesAgain() {
    const options = {
        timeout: 10000000
    };
    const mysql = require('mysql');
    const client = new JsonRpcClient('node', options)
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });
    
    await con.connect();

    var accounts:any = await asynqQuery(con, 'SELECT * FROM account');
    var foundAddresses = accounts.map((x:any) => x.address);

    const cliProgress = require('cli-progress');
    const progress = new cliProgress.SingleBar({
        format: '{percentage}% | {value}/{total} | {bar} || Address: {address} ||| ETA: {eta}s',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
        fps: 5
    });

    progress.start(foundAddresses.length, 0, {
        address: 'N/A'
    });

    for (var i in foundAddresses) {
        const address = foundAddresses[i];

        progress.update({
            address: address
        });

        try {
            await checkAddress(client, con, address);
        }
        catch (e) {
            console.log(address + " " + e);
        }

        progress.increment();
    }

    console.log("done");
}

async function checkAddress(client: JsonRpcClient, con: any, address: string) 
{
    var tokenBalances = new Map<string, number>();
    var accountBalance = await client.account.getAccount(address);

    accountBalance.forEach(async (x) => {
        var splitted = x.split('@');

        var token = splitted[1];

        tokenBalances.set(token, Number(splitted[0]));
    });
    
    try {
        tokenBalances.forEach(async (value: number, key: string) => {
            var result:any = await asynqQuery(con, 'SELECT * FROM account_token WHERE address=? AND token=?', [address, key]);

            if (result.length === 0) {
                await asynqQuery(con, 'INSERT INTO account_token SET ?', {address: address, token: key, amount: value});
            }
            else {
                await asynqQuery(con, 'UPDATE account_token SET amount=? WHERE address=? AND token=?', [value, address, key]);
            }
        });
    }
    catch (e) {
        console.log(e);
    }

    return true;
}

async function clenaup() 
{
    var query = "SELECT count(*), txID FROM icx_swap GROUP BY txId HAVING count(*) > 1;"
    const mysql = require('mysql');
    var con = await mysql.createConnection({
        host: "localhost",
        user: "defichain",
        password: "defichain",
        database : 'defichain'
    });
    
    await con.connect();

    var result:any = await asynqQuery(con, query);

    for (var entry in result) {
        var row = result[entry];

        var txId = row.txID;

        var query = "SELECT * FROM `icx_swap` WHERE `txId` = ?";

        var entries:any = await asynqQuery(con, query, [txId]);
        var first = true;

        for (var swapEntry in entries) {
            var swap = entries[swapEntry];

            if (first) {
                first = false;
                continue;
            }

            await asynqQuery(con, "DELETE FROM icx_swap WHERE id=?", [swap.id])

        }
    }
}

function asynqQuery(con: any, query: string, params?: any) {
    return new Promise((resolve, reject) =>{
        con.query(query, params, (err: any, result: any) => {
            if (err)
                return reject(err);
            resolve(result);
        });
    });

}

/*
async function loadTransactions() {
    const options = {
        timeout: 10000000
    };
    const client = new JsonRpcClient('node', options)

    const fs = require('fs');

    var tokens = new Map<string, Map<string, BigNumber>>();
    var erroredAccounts = new Array()

    var Progress = require('ts-progress');

    const csv = require('csvtojson')
    const csvFilePath = 'out.csv'
    const array = await csv().fromFile(csvFilePath);

    var progress = Progress.create({total: array.length, pattern: 'Progress: {current}/{total} | Remaining: {remaining} | Elapsed: {elapsed} ', textColor: 'blue'});

    const createCsvWriter = require('csv-writer').createObjectCsvWriter;
    const csvWriter = createCsvWriter({
        path: 'accounts.csv',
        header: [
            {id: 'account', title: 'account'},
            {id: 'timestamp', title: 'timestamp'},
            {id: 'btc', title: 'btc'}
        ]
    });

    for (var i = 0; i < array.length; i++) {
        var address = array[i].address;
        var timestamp = array[i].timestamp;
        progress.update();

        try { 
            var tokenValues = new Map<string, BigNumber>();
            var accountBalance = await client.account.getAccount(address);

            if (accountBalance.length == 0) {
                continue;
            }

            accountBalance.forEach(async (x) => {
                var splitted = x.split('@');

                var amount = new BigNumber(splitted[0]);
                var token = splitted[1];

                if (token == 'BTC') {
                    tokenValues.set(token, amount);

                    await csvWriter.writeRecords([{
                        account: address,
                        timestamp: timestamp,
                        btc: splitted[0]
                    }])
                }
            });
        } catch (e) { 
            erroredAccounts.push(address);
        } 
    }

    var addressCsv = new Array;
    var headers = [
        {id: 'address', title: 'address'},
    ];
    
    console.log('Errored Addresses:');
    console.log(erroredAccounts);
    var addedHeaders = new Array
    
    /*tokens.forEach(function(value: Map<string, BigNumber>, key: string) {
        var addressEntry:any = {
            address: key
        };

        value.forEach(function(value: BigNumber, key: string) {
            if (addedHeaders.indexOf(key)) {
                addedHeaders.push(key);
                headers.push({
                    id: key,
                    title: key
                });
            }
            addressEntry[key] = value.toString();
        });

        addressCsv.push(addressEntry);
    }); 
}*/

/**

    SELECT 2840 as cake_collateral, sum(btc) as on_chain, sum(btc) - 2840 as unbacked FROM (
        SELECT * FROM (SELECT SUM(amount) as btc FROM (SELECT * FROM account_token WHERE address <> '8defichainBurnAddressXXXXXXXdRQkSm' and token='BTC') as qry GROUP BY token) as qry
        UNION
        SELECT SUM(amount) as btc FROM (SELECT * FROM vault_collateral WHERE token='BTC') as qry
        UNION
        SELECT SUM(amount) as btc FROM (SELECT * FROM vault_batch_collateral WHERE token='BTC') as qry
        UNION
        SELECT SUM(reserveA) as btc FROM (SELECT * FROM poolpair WHERE symbol='BTC-DFI') as qry
    ) as qry;

    SELECT SUM(amountBeforeFilled) as before_icx, SUM(amountAfterFilled) as after_icx, SUM(amountAfterFilled) - SUM(amountBeforeFilled) as unbacked FROM icx_order;
 
    SELECT SUM(amount) as amount FROM (SELECT address, token, amount FROM account_token
    INNER JOIN icx_order ic ON ic.ownerAddress = address
    WHERE token='BTC') as qry
*/

//processIcxOrders()
// process()
//processListAccounts();
//processIcxOrderTransactions();
//processIcxOrderTransactionsLevel(1);
//processPoolPairs()
//processVaults()
//countAccountToAccountTransactions("daa72gjBe5WGd5Gsjpxjp6e5JJdDJHx9XN")
//processErroredAddresss();
//processAllAddressesAgain();
//clenaup();
processIcxAccounts();